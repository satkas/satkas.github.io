<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Satkas Blog (Posty o bash)</title><link>https://sataks.github.io/</link><description></description><atom:link href="https://sataks.github.io/categories/bash.xml" rel="self" type="application/rss+xml"></atom:link><language>pl</language><copyright>Contents © 2021 &lt;a href="mailto:pomoc@satkas.waw.pl"&gt;tk&lt;/a&gt; </copyright><lastBuildDate>Wed, 26 May 2021 13:36:49 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Bash - sprawdzenie czy proces jest aktywny z najmniejszymi uprawnieniami</title><link>https://sataks.github.io/posts/bash-sprawdzenie-czy-proces-jest-aktywny-z-najmniejszymi-uprawnieniami/</link><dc:creator>tk</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;a href="https://satkas.waw.pl/?post=bash-sprawdzenie-czy-proces-jest-aktywny-z-namniejszymi-uprawnieniami"&gt;&lt;img alt="Bash" src="https://satkas.waw.pl/plugins/news_manager/browser/pic.php?p=https://satkas.waw.pl/data/thumbs/images/thumbnail.bash-logo-web.png&amp;amp;c=1"&gt;&lt;/a&gt; Musiałem zrobić skrypt gdzie odpytuję usługi i sprawdzam czy "żyją" i podaję kod wyjśćia dla nagiosa.&lt;/p&gt;
&lt;p&gt;Wymaganie było aby zrobić to przy jak najmniejszym nadawaniu uprawnień.&lt;/p&gt;
&lt;p&gt;Niby prosta komenda systemctl is-active *.service jest dobra ale zdalne wykonanie skryptu przez nrpe nie chciało zaskoczyć. Czały cas w logach były komunikaty o u słabych uprawnieniach&lt;/p&gt;
&lt;p&gt;Skrypt wykonałem w Bash-u zaprzęgając do tego poczciwą komendę ps. Reszta to już tylko tablice. Dodatkowo problemem było jeszcze nazewnictwo  usług. Np Tomcat posiada proces java, a baza danych PostgreSQL uruchamia proces posmaster. W skrypcie uwzględniłem taki przypadek. Choć wiem, że nie jest elastyczny (można zrobić porównanie po stringach, a nie po indeksach).&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;

&lt;span class="nv"&gt;nameS&lt;/span&gt;&lt;span class="o"&gt;=(&lt;/span&gt;httpd java postmaster&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="nv"&gt;licznik1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; i &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;nameS&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;do&lt;/span&gt;
    ps -C &lt;span class="nv"&gt;$i&lt;/span&gt; &amp;gt;/dev/null
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$?&lt;/span&gt; -eq &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;then&lt;/span&gt; 
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$licznik1&lt;/span&gt; -eq &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;then&lt;/span&gt;
            wynikP&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;$licznik1&lt;/span&gt;&lt;span class="o"&gt;]=&lt;/span&gt;&lt;span class="s2"&gt;"Service Tomcat is active"&lt;/span&gt;
            &lt;span class="o"&gt;((&lt;/span&gt;licznik1++&lt;span class="o"&gt;))&lt;/span&gt;
        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$licznik1&lt;/span&gt; -eq &lt;span class="m"&gt;2&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;then&lt;/span&gt;
                        wynikP&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;$licznik1&lt;/span&gt;&lt;span class="o"&gt;]=&lt;/span&gt;&lt;span class="s2"&gt;"Service PostgreSQL is active"&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;    
            wynikP&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;$licznik1&lt;/span&gt;&lt;span class="o"&gt;]=&lt;/span&gt;&lt;span class="s2"&gt;"Service &lt;/span&gt;&lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="s2"&gt; is active"&lt;/span&gt;
            &lt;span class="o"&gt;((&lt;/span&gt;licznik1++&lt;span class="o"&gt;))&lt;/span&gt;
        &lt;span class="k"&gt;fi&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$licznik1&lt;/span&gt; -eq &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;then&lt;/span&gt;
                        wynikF&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;$licznik1&lt;/span&gt;&lt;span class="o"&gt;]=&lt;/span&gt;&lt;span class="s2"&gt;"Service Tomcat is inactive"&lt;/span&gt;
                        &lt;span class="o"&gt;((&lt;/span&gt;licznik1++&lt;span class="o"&gt;))&lt;/span&gt;
                &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$licznik1&lt;/span&gt; -eq &lt;span class="m"&gt;2&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;then&lt;/span&gt;
                        wynikF&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;$licznik1&lt;/span&gt;&lt;span class="o"&gt;]=&lt;/span&gt;&lt;span class="s2"&gt;"Service PostgreSQL is inactive"&lt;/span&gt;
                &lt;span class="k"&gt;else&lt;/span&gt;
                        wynikF&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;$licznik1&lt;/span&gt;&lt;span class="o"&gt;]=&lt;/span&gt;&lt;span class="s2"&gt;"Service &lt;/span&gt;&lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="s2"&gt; is inactive"&lt;/span&gt;
                        &lt;span class="o"&gt;((&lt;/span&gt;licznik1++&lt;span class="o"&gt;))&lt;/span&gt;
                &lt;span class="k"&gt;fi&lt;/span&gt;
    &lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="si"&gt;${#&lt;/span&gt;&lt;span class="nv"&gt;wynikP&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt; -eq &lt;span class="m"&gt;3&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;then&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"All services is active: &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;wynikP&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="nb"&gt;exit&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;wynikF&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="nb"&gt;exit&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aktualizacja: 20 wrzesień 2020r.&lt;/p&gt;
&lt;p&gt;Skorygowałem skrypt na taki, który nie używa tablic indeksowych tylko polecenia case. Wydaje się prostszy.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;

&lt;span class="nv"&gt;nameS&lt;/span&gt;&lt;span class="o"&gt;=(&lt;/span&gt;upowerd gnome-shell nautilus&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="nv"&gt;SUCCESS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;""&lt;/span&gt;
&lt;span class="nv"&gt;FAILED&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;""&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; i &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;nameS&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;do&lt;/span&gt;
    ps -C &lt;span class="nv"&gt;$i&lt;/span&gt; &amp;gt;/dev/null
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$?&lt;/span&gt; -eq &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;then&lt;/span&gt; 
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nv"&gt;$i&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;
          &lt;span class="s2"&gt;"upowerd"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
            &lt;span class="nv"&gt;SUCCESS&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="s2"&gt;"Service &lt;/span&gt;&lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="s2"&gt; is active "&lt;/span&gt; &lt;span class="p"&gt;;;&lt;/span&gt;
          &lt;span class="s2"&gt;"gnome-shell"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
            &lt;span class="nv"&gt;SUCCESS&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="s2"&gt;"Service Gnome is active "&lt;/span&gt; &lt;span class="p"&gt;;;&lt;/span&gt;
          &lt;span class="s2"&gt;"nautilus"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
            &lt;span class="nv"&gt;SUCCESS&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="s2"&gt;"Service Menadzer plikow is active"&lt;/span&gt; &lt;span class="p"&gt;;;&lt;/span&gt;
        &lt;span class="k"&gt;esac&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
          &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nv"&gt;$i&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;
          &lt;span class="s2"&gt;"upowerd"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
            &lt;span class="nv"&gt;FAILED&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="s2"&gt;"Service &lt;/span&gt;&lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="s2"&gt; is deactive "&lt;/span&gt;&lt;span class="p"&gt;;;&lt;/span&gt;
          &lt;span class="s2"&gt;"gnome-shell"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
            &lt;span class="nv"&gt;FAILED&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="s2"&gt;"Service Gnome is deactive "&lt;/span&gt;&lt;span class="p"&gt;;;&lt;/span&gt;
          &lt;span class="s2"&gt;"nautilus"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
            &lt;span class="nv"&gt;FAILED&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="s2"&gt;"Service Manadzer plikow is deactive"&lt;/span&gt;&lt;span class="p"&gt;;;&lt;/span&gt;
        &lt;span class="k"&gt;esac&lt;/span&gt;
    &lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; -z &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$FAILED&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;then&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$SUCCESS&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="nb"&gt;exit&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$FAILED&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="nb"&gt;exit&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><category>bash</category><category>linux</category><guid>https://sataks.github.io/posts/bash-sprawdzenie-czy-proces-jest-aktywny-z-najmniejszymi-uprawnieniami/</guid><pubDate>Thu, 17 Sep 2020 22:00:00 GMT</pubDate></item><item><title>Bash - generowanie hasła</title><link>https://sataks.github.io/posts/bash-generowanie-hasla/</link><dc:creator>tk</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;a href="https://satkas.waw.pl/?post=bash-generowanie-hasla"&gt;&lt;img alt="Bash" src="https://satkas.waw.pl/plugins/news_manager/browser/pic.php?p=https://satkas.waw.pl/data/thumbs/images/thumbnail.bash-logo-web.png&amp;amp;c=1"&gt;&lt;/a&gt; Jest wiele sposobów na wygenerowanie hasła. Służą do tego wyspecjalizowane programy(pwgen, keepass itp). Link do tej &lt;a href="https://www.howtogeek.com/howto/30184/10-ways-to-generate-a-random-password-from-the-command-line/"&gt;strony&lt;/a&gt; pokazuje "ocean możliwości". Można również samemu sobie stworzyć automat w postacji skryptu bash. Bash się do tego nadaje idealnie.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!/usr/bin/env sh&lt;/span&gt;

&lt;span class="nv"&gt;sumaZnakow&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'16'&lt;/span&gt;
&lt;span class="nv"&gt;probkiHasel&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'6'&lt;/span&gt;

&lt;span class="c1"&gt;#opcja z argumentami&lt;/span&gt;
&lt;span class="c1"&gt;#sumaZnakow=$1&lt;/span&gt;
&lt;span class="c1"&gt;#probkiHasel=$2&lt;/span&gt;

&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Generowanie &lt;/span&gt;&lt;span class="nv"&gt;$probkiHasel&lt;/span&gt;&lt;span class="s2"&gt; haseł. Hasło ma długość &lt;/span&gt;&lt;span class="nv"&gt;$sumaZnakow&lt;/span&gt;&lt;span class="s2"&gt; znaków"&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; n&amp;lt;&lt;span class="nv"&gt;$probkiHasel&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; n++&lt;span class="o"&gt;))&lt;/span&gt;
 &lt;span class="k"&gt;do&lt;/span&gt; dd &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/urandom &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;&amp;gt; /dev/null &lt;span class="p"&gt;|&lt;/span&gt; uuencode -m - &lt;span class="p"&gt;|&lt;/span&gt; sed -ne 2p &lt;span class="p"&gt;|&lt;/span&gt; cut -c-&lt;span class="nv"&gt;$sumaZnakow&lt;/span&gt; 
&lt;span class="k"&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wartości dwóch pierwszych zmiennych można zastąpić argumentami $1, $2&lt;/p&gt;
&lt;p&gt;Wtedy wywołanie będzie:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;bash generowanieHasla.sh &lt;span class="m"&gt;16&lt;/span&gt; &lt;span class="m"&gt;6&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h6&gt;Aktualizacja&lt;/h6&gt;
&lt;p&gt;W Ubuntu (u mnie 20.04) trzeba doinstalować pakiet sharutils aby można było używać narzędzia uuencode.
Zmodyfikowałem zatem skrypt aby automatycznie doinstalowywał pakiet.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!/usr/bin/env sh&lt;/span&gt;

&lt;span class="nv"&gt;sumaZnakow&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'16'&lt;/span&gt;
&lt;span class="nv"&gt;probkiHasel&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'20'&lt;/span&gt;

&lt;span class="o"&gt;[&lt;/span&gt; -f /usr/bin/uuencode &lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Generowanie Haseł"&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt;  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Brak zainstalowanego pakietu uuencode &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;sudo apt install -q sharutils -y&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;span class="c1"&gt;#opcja z argumentami&lt;/span&gt;
&lt;span class="c1"&gt;#sumaZnakow=$1&lt;/span&gt;
&lt;span class="c1"&gt;#probkiHasel=$2&lt;/span&gt;

&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Generowanie &lt;/span&gt;&lt;span class="nv"&gt;$probkiHasel&lt;/span&gt;&lt;span class="s2"&gt; haseł. Hasło ma długość &lt;/span&gt;&lt;span class="nv"&gt;$sumaZnakow&lt;/span&gt;&lt;span class="s2"&gt; znaków"&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; n&amp;lt;&lt;span class="nv"&gt;$probkiHasel&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; n++&lt;span class="o"&gt;))&lt;/span&gt;
 &lt;span class="k"&gt;do&lt;/span&gt; dd &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/urandom &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;&amp;gt; /dev/null &lt;span class="p"&gt;|&lt;/span&gt; uuencode -m - &lt;span class="p"&gt;|&lt;/span&gt; sed -ne 2p &lt;span class="p"&gt;|&lt;/span&gt; cut -c-&lt;span class="nv"&gt;$sumaZnakow&lt;/span&gt; 
&lt;span class="k"&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><category>bash</category><category>linux</category><category>password</category><guid>https://sataks.github.io/posts/bash-generowanie-hasla/</guid><pubDate>Mon, 07 Sep 2020 22:00:00 GMT</pubDate></item><item><title>BASH - spacje, spacje, spacje</title><link>https://sataks.github.io/posts/bash-spacje-spacje-spacje/</link><dc:creator>tk</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;a href="https://satkas.waw.pl/?post=bash-spacje-spacje-spacje"&gt;&lt;img alt="Bash" src="https://satkas.waw.pl/plugins/news_manager/browser/pic.php?p=https://satkas.waw.pl/data/thumbs/images/thumbnail.bash-logo-web.png&amp;amp;c=1" title="Bash"&gt;&lt;/a&gt;  Świat nie jest idealny. Jednym z wielu aspektów, które obrazują nam taki obraz świata są przyzwyczajenia w tworzeniu plików i katalogów.&lt;/p&gt;
&lt;p&gt;Według tzw "świata *nixowgo" pliki/katalogi powinno się tworzyć bez spacji aby późniejsze przetwarzanie nie powodowało problemów. W swiecie windows-a nie ma to większego znaczenia i system ten "przyzwyczaił" ludzi do tworzenia nazw plików i katalogów tak jakby mieli napisać krótki esej.&lt;/p&gt;
&lt;p&gt;Aby w Linuksie obejść problem spacji możemy posłużyć się pętlą while, która przetwarza pliki/wyjśćia innych poleceń linia po lini.&lt;/p&gt;
&lt;p&gt;I tak jeśli chcemy coś zrobić z plikiem (np skopiować, przenieść w iine miejsce) możemy zastosować rozwiązanie:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nb"&gt;read&lt;/span&gt; p&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt;
  mv &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="s2"&gt;"/tmp/&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;p&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;find . -mindepth &lt;span class="m"&gt;1&lt;/span&gt; -maxdepth &lt;span class="m"&gt;1&lt;/span&gt; -type f ! -name &lt;span class="s2"&gt;".*"&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Pętla filtruje tylko pliki i  przenosi pliki do katalogu /tmp&lt;/p&gt;
&lt;p&gt;Komenda&lt;/p&gt;
&lt;pre class="code literal-block"&gt;find . -mindepth &lt;span class="m"&gt;1&lt;/span&gt; -maxdepth &lt;span class="m"&gt;1&lt;/span&gt; -type f ! -name &lt;span class="s2"&gt;".*"&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;wyszukuje tylko pliki w katalogu, którym wykonywany jest skrypt i nie bierze pod uwagę tzw plików ukrytych&lt;/p&gt;
&lt;p&gt;Nie ma znaczenia czy plik ma spację w nazwie.&lt;/p&gt;&lt;/div&gt;</description><category>bash</category><category>linux</category><guid>https://sataks.github.io/posts/bash-spacje-spacje-spacje/</guid><pubDate>Wed, 29 Apr 2020 22:00:00 GMT</pubDate></item><item><title>Czas epoki unix-a - konwersja</title><link>https://sataks.github.io/posts/czas-epoki-unix-a-konwersja/</link><dc:creator>tk</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;a href="https://satkas.waw.pl/?post=czas-epoki-unix-a-konwersja"&gt;&lt;img alt="Bash" src="https://satkas.waw.pl/plugins/news_manager/browser/pic.php?p=https://satkas.waw.pl/data/thumbs/images/thumbnail.bash-logo-web.png&amp;amp;c=1" title="Bash"&gt;&lt;/a&gt; Czas w Linuksie liczymy wg tzw epoki unix-a. Co to znaczy?&lt;/p&gt;
&lt;p&gt;Jeśli wydamy komendę w Linuksie (terminal)&lt;/p&gt;
&lt;pre class="code literal-block"&gt; date &lt;span class="s2"&gt;"+%s"&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;to otrzymamy wynik&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="m"&gt;1574511413&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;który nie jest czytelny dla człowieka. Przyzwyczajeni jesteśmy do innego schematu przedstawiania daty i czasu. Czas który widzimy pokazuje ile sekund upłyneło od daty  1970-01-01 00:00:00 UTC.&lt;/p&gt;
&lt;p&gt;Aby odczytać czas zapisany w notacji unix-owej możemy użyć komendy&lt;/p&gt;
&lt;pre class="code literal-block"&gt;date -d @1574511413
&lt;/pre&gt;
&lt;p&gt;Możemy również użyć perla&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;perl&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="s"&gt;'print scalar(localtime(1574511413)), "\n"'&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Z zapisem bardzo często można się spotkać w bazach danych lub logach.&lt;/p&gt;
&lt;p&gt;Jak można wykorzystać konwersję w locie?&lt;/p&gt;
&lt;p&gt;Przeglądając logi mojego pihole możemy użyć jednolinijkowca awk&lt;/p&gt;
&lt;p&gt;Najpierw wgląd jak wygląda standardowe wyjście:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="m"&gt;1574514699&lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="m"&gt;192&lt;/span&gt;.168.80.11&lt;span class="p"&gt;|&lt;/span&gt;POST /admin/list.php?l&lt;span class="o"&gt;=&lt;/span&gt;black HTTP/1.1&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="m"&gt;200&lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="m"&gt;20907&lt;/span&gt;
&lt;span class="m"&gt;1574514700&lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="m"&gt;192&lt;/span&gt;.168.80.11&lt;span class="p"&gt;|&lt;/span&gt;GET /admin/img/donate.gif HTTP/1.1&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="m"&gt;200&lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="m"&gt;3592&lt;/span&gt;
&lt;span class="m"&gt;1574514700&lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="m"&gt;192&lt;/span&gt;.168.80.11&lt;span class="p"&gt;|&lt;/span&gt;GET /admin/scripts/pi-hole/php/get.php?list&lt;span class="o"&gt;=&lt;/span&gt;black&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nv"&gt;_&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1574514700224&lt;/span&gt; HTTP/1.1&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="m"&gt;200&lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="m"&gt;88&lt;/span&gt;
&lt;span class="m"&gt;1574514717&lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="m"&gt;192&lt;/span&gt;.168.80.11&lt;span class="p"&gt;|&lt;/span&gt;POST /admin/scripts/pi-hole/php/sub.php HTTP/1.1&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="m"&gt;200&lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Teraz wykonujemy polecenie:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nx"&gt;awk&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nx"&gt;F&lt;/span&gt;&lt;span class="s2"&gt;"|"&lt;/span&gt;  &lt;span class="s1"&gt;'{ $1=strftime("%F %T",$1); print }'&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nx"&gt;var&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="kr"&gt;log&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nx"&gt;lighttpd&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nx"&gt;access&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="kr"&gt;log&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Funkcja strftime nie jest dostepna w standardowym awk. Jak wykonamy polecenie pokaże nam się błąd:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;error: &lt;span class="s2"&gt;"function strftime never defined"&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Musimy doinstalować gawk. Na raspberrypi zainstalowanego mam Resbiana (Debian) wykonamy więc:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;apt get install gawk
&lt;/pre&gt;
&lt;p&gt;Następnie można wykonać ponownie polecenie&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nx"&gt;awk&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nx"&gt;F&lt;/span&gt;&lt;span class="s2"&gt;"|"&lt;/span&gt;  &lt;span class="s1"&gt;'{ $1=strftime("%F %T",$1); print }'&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nx"&gt;var&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="kr"&gt;log&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nx"&gt;lighttpd&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nx"&gt;access&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="kr"&gt;log&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Wynik, który nam się ukaże to:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="m"&gt;2019&lt;/span&gt;-11-23 &lt;span class="m"&gt;14&lt;/span&gt;:11:37 &lt;span class="m"&gt;192&lt;/span&gt;.168.80.11 GET /admin/style/vendor/bootstrap/fonts/glyphicons-halflings-regular.woff2 HTTP/1.1 &lt;span class="m"&gt;200&lt;/span&gt; &lt;span class="m"&gt;18028&lt;/span&gt;
&lt;span class="m"&gt;2019&lt;/span&gt;-11-23 &lt;span class="m"&gt;14&lt;/span&gt;:11:37 &lt;span class="m"&gt;192&lt;/span&gt;.168.80.11 GET /admin/img/logo.svg HTTP/1.1 &lt;span class="m"&gt;200&lt;/span&gt; &lt;span class="m"&gt;1649&lt;/span&gt;
&lt;span class="m"&gt;2019&lt;/span&gt;-11-23 &lt;span class="m"&gt;14&lt;/span&gt;:11:39 &lt;span class="m"&gt;192&lt;/span&gt;.168.80.11 POST /admin/list.php?l&lt;span class="o"&gt;=&lt;/span&gt;black HTTP/1.1 &lt;span class="m"&gt;200&lt;/span&gt; &lt;span class="m"&gt;20907&lt;/span&gt;
&lt;span class="m"&gt;2019&lt;/span&gt;-11-23 &lt;span class="m"&gt;14&lt;/span&gt;:11:40 &lt;span class="m"&gt;192&lt;/span&gt;.168.80.11 GET /admin/img/donate.gif HTTP/1.1 &lt;span class="m"&gt;200&lt;/span&gt; &lt;span class="m"&gt;3592&lt;/span&gt;
&lt;span class="m"&gt;2019&lt;/span&gt;-11-23 &lt;span class="m"&gt;14&lt;/span&gt;:11:40 &lt;span class="m"&gt;192&lt;/span&gt;.168.80.11 GET /admin/scripts/pi-hole/php/get.php?list&lt;span class="o"&gt;=&lt;/span&gt;black&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nv"&gt;_&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1574514700224&lt;/span&gt; HTTP/1.1 &lt;span class="m"&gt;200&lt;/span&gt; &lt;span class="m"&gt;88&lt;/span&gt;
&lt;span class="m"&gt;2019&lt;/span&gt;-11-23 &lt;span class="m"&gt;14&lt;/span&gt;:11:57 &lt;span class="m"&gt;192&lt;/span&gt;.168.80.11 POST /admin/scripts/pi-hole/php/sub.php HTTP/1.1 &lt;span class="m"&gt;200&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><category>bash</category><category>ntp</category><category>time</category><guid>https://sataks.github.io/posts/czas-epoki-unix-a-konwersja/</guid><pubDate>Fri, 22 Nov 2019 23:00:00 GMT</pubDate></item><item><title>Kontrola sesji użytkowników w Linuksie</title><link>https://sataks.github.io/posts/kontrola-sesji-uzytkownikow-w-linuksie/</link><dc:creator>tk</dc:creator><description>&lt;div&gt;&lt;p&gt;Często słyszy się, że w terminalu/konsoli ciężko zarządza się zalogowanymi użytkownikami.&lt;/p&gt;
&lt;p&gt;To prawda - jeśli myślimy w perspektywie zarządzania Windowsami. W Linuksie też znajdziemy narzędzia, które pozwalają nam sprawnie zarządzać użytkownikami.&lt;/p&gt;
&lt;p&gt;Jest kilka możliwości. Pierwsza to znajome narzędzie who&lt;/p&gt;
&lt;p&gt;Za man-em who - show who is logged on&lt;/p&gt;
&lt;p&gt;Jeśli chcemy zobaczyć kto jest zalogowany w systemie to wydajemy komendę:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;who

root@raspberrypi:~# who
     pi      pts/0       &lt;span class="m"&gt;2019&lt;/span&gt;-11-09 &lt;span class="m"&gt;13&lt;/span&gt;:54 &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;192&lt;/span&gt;.168.80.42&lt;span class="o"&gt;)&lt;/span&gt;
     user1   pts/1       &lt;span class="m"&gt;2019&lt;/span&gt;-11-09 &lt;span class="m"&gt;15&lt;/span&gt;:13 &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;192&lt;/span&gt;.168.80.42&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Jest to tylko poglądowa informacja. Aby zobaczyć trochę więcej informacji na temat sesji użytkownika wydajemy polecenie:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;root@raspberrypi:~# who -a
           start systemu &lt;span class="m"&gt;1970&lt;/span&gt;-01-01 &lt;span class="m"&gt;01&lt;/span&gt;:00
           LOGIN     tty1        &lt;span class="m"&gt;2019&lt;/span&gt;-11-09 &lt;span class="m"&gt;12&lt;/span&gt;:33              &lt;span class="m"&gt;473&lt;/span&gt; &lt;span class="nv"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;tty1
           run-level &lt;span class="m"&gt;3&lt;/span&gt; &lt;span class="m"&gt;2019&lt;/span&gt;-11-09 &lt;span class="m"&gt;12&lt;/span&gt;:33
           pi      - pts/0       &lt;span class="m"&gt;2019&lt;/span&gt;-11-09 &lt;span class="m"&gt;13&lt;/span&gt;:54  .          &lt;span class="m"&gt;794&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;192&lt;/span&gt;.168.80.42&lt;span class="o"&gt;)&lt;/span&gt;
           user1   + pts/1       &lt;span class="m"&gt;2019&lt;/span&gt;-11-09 &lt;span class="m"&gt;15&lt;/span&gt;:13 &lt;span class="m"&gt;00&lt;/span&gt;:07       &lt;span class="m"&gt;1066&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;192&lt;/span&gt;.168.80.42&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Pierwsza kolumna informuje kto jest zalogowany&lt;/p&gt;
&lt;p&gt;Druga kolumna informuje do jakiego pseudoterminala lub terminala dany użytkownik został przypisany.&lt;/p&gt;
&lt;p&gt;Trzecia kolumna informuje czas kiedy zostało to uczynione.&lt;/p&gt;
&lt;p&gt;Czwarta jaki jest PID procesu (będzie ważny jeśli będziemy niedelikatnie podziękować użytkownikowi)&lt;/p&gt;
&lt;p&gt;Piąta kolumna informuje skąd nastąpiło logowanie (może to być adres IP lub lokalny terminal czyli tty)&lt;/p&gt;
&lt;p&gt;Jeśli chcemy osunąć sesję użytkownika to wydajemy polecenie:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nb"&gt;kill&lt;/span&gt; PID czyli w moim przypadku &lt;span class="nb"&gt;kill&lt;/span&gt; &lt;span class="m"&gt;1066&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;polecenie who z opcją -H pokazuje ładnie nam nagłówki kolumn.&lt;/p&gt;
&lt;p&gt;Jak wiemy w systemie są nie tylko użytkownicy tzw standardowi (założeni przez administratora) ale również systemowi. Tworzeni są zazwyczaj na potrzeby konkretnych aplikacji.&lt;/p&gt;
&lt;p&gt;Aby ich wyświetlić wydajemy polecenie:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;who -Hl &lt;span class="c1"&gt;##l jak lolek&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Drugim narzedziem jest komenda w. Jest bardziej bogatszą wersją w informacje ale brakuje jej jednej ważnej informacji PID procesu. Trzeba szukać jaki proces ma użytkownik pseudoerminala/terminala.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;ps -ef &lt;span class="p"&gt;|&lt;/span&gt;awk &lt;span class="s1"&gt;'$9 ~ /pts/ { print $0 }'&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;bądź&lt;/p&gt;
&lt;pre class="code literal-block"&gt;ps -ef &lt;span class="p"&gt;|&lt;/span&gt;awk &lt;span class="s1"&gt;'$9 ~ /pts/ || $6 ~ /tty/ { print $0 }'&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Zdecydowanie polecam ostatnie polecenie. Ma najwięcej możliwość i związany jest z wraz z wprowadzeniem systemd.&lt;/p&gt;
&lt;p&gt;Komenda loginctl -l pokazuje sesje użytkowników&lt;/p&gt;
&lt;p&gt;Aby wyświetlić więcej informacji dotyczących sesji wykonujemy polecenie:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;loginctl session-status id_sesji
&lt;/pre&gt;
&lt;p&gt;Aby ubić sesję uzytkownika wydajemy polecenie:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;loginctl terminate-session id_sesji
&lt;/pre&gt;
&lt;p&gt;lub&lt;/p&gt;
&lt;pre class="code literal-block"&gt;loginctl kill-session id_sesji
&lt;/pre&gt;&lt;/div&gt;</description><category>bash</category><category>linux</category><guid>https://sataks.github.io/posts/kontrola-sesji-uzytkownikow-w-linuksie/</guid><pubDate>Fri, 08 Nov 2019 23:00:00 GMT</pubDate></item><item><title>Bash - wyświetlenie plików w strukturze podobnych katalogów</title><link>https://sataks.github.io/posts/bash-wyswietlenie-plikow-w-strukturze-podobnych-katalogow/</link><dc:creator>tk</dc:creator><description>&lt;div&gt;&lt;p&gt;Wyświetlenie plików (lub wpisanie ich do pliku) w pewnej usystematyzowanej strukturze katalogów.&lt;/p&gt;
&lt;p&gt;Katalogów jest bardzo dużo ja na potrzeby przykładu utworzyłem katalog-120 do katalog-130. Praca ręczna nigdy nie zostanie wzięta pod uwagę więc trzeba zrobić automat.&lt;/p&gt;
&lt;p&gt;Musimy wyświetlić pliki z pewnego przedziału np katalog-120 do katalog-129. Rozwiązań zapewne jest nieskończenie wiele.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pierwsze rozwiązanie wykorzystuje printf&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nb"&gt;printf&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$PWD&lt;/span&gt;&lt;span class="s2"&gt;/%s\n"&lt;/span&gt; katalog-12&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;-9&lt;span class="o"&gt;]&lt;/span&gt;/*


/home/tk/skrypty/bash/lab/katalog-120/file2-1
/home/tk/skrypty/bash/lab/katalog-122/file2-1
/home/tk/skrypty/bash/lab/katalog-123/plik1
/home/tk/skrypty/bash/lab/katalog-125/plik5_1
/home/tk/skrypty/bash/lab/katalog-126/file6-1
&lt;/pre&gt;
&lt;p&gt;Jeśli chcielibyśmy wypisać same nazwy plików to wynik wkładamy do pętli i poddajemy pod narzędzie basename.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;for&lt;/span&gt; i &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;printf&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$PWD&lt;/span&gt;&lt;span class="s2"&gt;/%s\n"&lt;/span&gt; katalog-12&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;-9&lt;span class="o"&gt;]&lt;/span&gt;/*&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt; basename &lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;done&lt;/span&gt;
&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Drugie rozwiązanie wykorzystuje narzędzie find (moim zdaniem bardziej uniwersalna ponieważ działa również jeśli w katalogach są podkatalogi)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="code literal-block"&gt;find ./katalog-12&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;-6&lt;span class="o"&gt;]&lt;/span&gt; -type f -exec basename &lt;span class="o"&gt;{}&lt;/span&gt; &lt;span class="se"&gt;\;&lt;/span&gt;

file2-1
file2-1
plik1
plik5_1
file6-1
&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Trzecie rozwiązanie wykorzystuje narzędzie ls&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="code literal-block"&gt;ls -1 katalog-12&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;-7&lt;span class="o"&gt;]&lt;/span&gt;/* &lt;span class="p"&gt;|&lt;/span&gt;tr &lt;span class="s2"&gt;"\n"&lt;/span&gt; &lt;span class="s2"&gt;"\0"&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;xargs -0 -n &lt;span class="m"&gt;1&lt;/span&gt; basename
&lt;/pre&gt;
&lt;p&gt;bądź krócej:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;ls katalog-12&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;-7&lt;span class="o"&gt;]&lt;/span&gt;/* &lt;span class="p"&gt;|&lt;/span&gt;xargs -n &lt;span class="m"&gt;1&lt;/span&gt; basename
&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;I kolejna wariacja&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;for&lt;/span&gt; i &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;find . -print &lt;span class="p"&gt;|&lt;/span&gt;grep &lt;span class="s2"&gt;"katalog-12[0-9]"&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="o"&gt;[[&lt;/span&gt; -f &lt;span class="nv"&gt;$i&lt;/span&gt; &lt;span class="o"&gt;]]&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; basename &lt;span class="nv"&gt;$i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;done&lt;/span&gt;
&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Bonus w postaci kodu w perl-u&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="ch"&gt;#!/usr/bin/perl&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;strict&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;warnings&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;File::Basename&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;my&lt;/span&gt; &lt;span class="nv"&gt;@files&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;glob&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'/home/tk/skrypty/bash/lab/katalog-12[0-5]/*'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;foreach&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;@files&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;basename&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$_&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s"&gt;"\n"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><category>bash</category><category>linux</category><guid>https://sataks.github.io/posts/bash-wyswietlenie-plikow-w-strukturze-podobnych-katalogow/</guid><pubDate>Fri, 20 Sep 2019 22:00:00 GMT</pubDate></item><item><title>Bash - pobieranie wartości z pliku xml</title><link>https://sataks.github.io/posts/bash-pobieranie-wartosci-z-pliku-xml/</link><dc:creator>tk</dc:creator><description>&lt;div&gt;&lt;p&gt;Czasami potrzebujemy przetworzyć plik xml. Najprawdopodobniej wszystkie liczące się języki programowania mają w swoich zasobach funkcje, które takie operacje realizują. Jeśli chodzi o bash-a to jest trochę inaczej ale jak na środowisko Linuksa przystało zrealizować to zadanie możemy różnymi innymi narzędziami.&lt;/p&gt;
&lt;p&gt;W systemie (u mnie OpenSuse 15.1) instalujemy potrzebne narzędzie:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo zypper &lt;span class="k"&gt;in&lt;/span&gt; xmlstarlet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Za plik xml posłuży nam ogólnodostępny plik w serwisie GDDKiA (Generalna Dyrekcja Dróg Krajowych i Autostrad) umieszczony tutaj: https://www.gddkia.gov.pl/dane/zima_html/utrdane.xml&lt;/p&gt;
&lt;p&gt;W podanym pliku mamy umieszczone dane z remontów, prac w całej Polsce na drogach administrowanych przez GDDKiA.&lt;/p&gt;
&lt;p&gt;Mnie interesuje ile prowadzonych jest inwestycji w poszczególnych województwach. Taką informację możemy wydobyć w bashu tzw jednolinijkowcem.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;curl -s -q https://www.gddkia.gov.pl/dane/zima_html/utrdane.xml &lt;span class="p"&gt;|&lt;/span&gt;xmlstarlet sel -t -m &lt;span class="s2"&gt;"utrudnienia"&lt;/span&gt; -m &lt;span class="s2"&gt;"utr"&lt;/span&gt; -v &lt;span class="s2"&gt;"woj"&lt;/span&gt; -n &lt;span class="p"&gt;|&lt;/span&gt;sort &lt;span class="p"&gt;|&lt;/span&gt;uniq -c &lt;span class="p"&gt;|&lt;/span&gt;sort -k1 -r
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wynik jaki dostanemy to:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="m"&gt;65&lt;/span&gt; mazowieckie
&lt;span class="m"&gt;56&lt;/span&gt; małopolskie
&lt;span class="m"&gt;36&lt;/span&gt; kujawsko-pomorskie
&lt;span class="m"&gt;35&lt;/span&gt; zachodniopomorskie
&lt;span class="m"&gt;30&lt;/span&gt; śląskie
&lt;span class="m"&gt;28&lt;/span&gt; wielkopolskie
&lt;span class="m"&gt;24&lt;/span&gt; lubuskie
&lt;span class="m"&gt;22&lt;/span&gt; warmińsko-mazurskie
&lt;span class="m"&gt;19&lt;/span&gt; lubelskie
&lt;span class="m"&gt;17&lt;/span&gt; podkarpackie
&lt;span class="m"&gt;15&lt;/span&gt; świętokrzyskie
&lt;span class="m"&gt;13&lt;/span&gt; opolskie
&lt;span class="m"&gt;13&lt;/span&gt; łódzkie
&lt;span class="m"&gt;11&lt;/span&gt; pomorskie
&lt;span class="m"&gt;11&lt;/span&gt; podlaskie
&lt;span class="m"&gt;11&lt;/span&gt; dolnośląskie
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><category>bash</category><category>linux</category><category>xml</category><guid>https://sataks.github.io/posts/bash-pobieranie-wartosci-z-pliku-xml/</guid><pubDate>Wed, 19 Jun 2019 22:00:00 GMT</pubDate></item><item><title>Filtrowanie logów poczty</title><link>https://sataks.github.io/posts/filtrowanie-logow-poczty/</link><dc:creator>tk</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;img alt="Postfix" src="https://satkas.waw.pl/plugins/news_manager/browser/pic.php?p=https://satkas.waw.pl/data/thumbs/images/thumbnail.postfix.png&amp;amp;c=1" title="Postfix"&gt;  Potrzebowałem na szybko wyciągnąć wszystkie adresy IP z pliku /var/log/mail.log, które wylądowały w specjalnym folderze z niechcianą pocztą. IP-ki będą wprowadzone na czarną listę adresów.&lt;/p&gt;
&lt;p&gt;Wchodzimy do określonego folderu z niechcianą pocztą i wykonujemy polecenie:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;grep -h -o -E &lt;span class="s1"&gt;'[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'&lt;/span&gt; *  &lt;span class="p"&gt;|&lt;/span&gt;sort&lt;span class="p"&gt;|&lt;/span&gt;uniq &lt;span class="p"&gt;|&lt;/span&gt;grep -v &lt;span class="s2"&gt;".0&lt;/span&gt;$&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;grep -v &lt;span class="s2"&gt;"127.0.0.1"&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;Wyjaśnienie:&lt;/h5&gt;
&lt;p&gt;Narzędzie grep jest świetnym narzędziem w powłoce BASH na takie zabawy.&lt;/p&gt;
&lt;p&gt;Fraza &lt;code&gt;'[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'&lt;/code&gt; określa adres IP do wyszukania.&lt;/p&gt;
&lt;p&gt;Część &lt;code&gt;grep -v ".0$"&lt;/code&gt; realizuje pomijanie całych podsieci (np. x.x.x.0/24)&lt;/p&gt;
&lt;p&gt;Część &lt;code&gt;grep -v "127.0.0.1"&lt;/code&gt; pomija adres loopback, który nie ma nic wspólnego z adresem serwera clienta.&lt;/p&gt;
&lt;p&gt;Teraz dodajemy adresy do pliku (plik czarnej listy zdefiniowaliśmy w main.cf):&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;x.x.x.x REJECT

....

....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;i klient dostaję zwrotkę na swoją pocztę (wiem, wiem spamerzy mają to głęboko :) )&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Sep &lt;span class="m"&gt;15&lt;/span&gt; &lt;span class="m"&gt;09&lt;/span&gt;:12:42 rod postfix/smtpd&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;14454&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;: NOQUEUE: reject: RCPT from laconic.pauladowson.com&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;192&lt;/span&gt;.155.99.74&lt;span class="o"&gt;]&lt;/span&gt;: &lt;span class="m"&gt;554&lt;/span&gt; &lt;span class="m"&gt;5&lt;/span&gt;.7.1 &amp;lt;laconic.pauladowson.com&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;192&lt;/span&gt;.155.99.74&lt;span class="o"&gt;]&lt;/span&gt;&amp;gt;: Client host rejected: Access denied&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nv"&gt;from&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&amp;lt;milenaxjjpgegbednarek@accvxz.com&amp;gt; &lt;span class="nv"&gt;to&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&amp;lt;jakisnaszemail@jakasnaszadomena&amp;gt; &lt;span class="nv"&gt;proto&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;ESMTP &lt;span class="nv"&gt;helo&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&amp;lt;laconic.accvxz.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><category>bash</category><category>linux</category><category>poczta</category><category>postfix</category><category>spam</category><guid>https://sataks.github.io/posts/filtrowanie-logow-poczty/</guid><pubDate>Fri, 14 Sep 2018 22:00:00 GMT</pubDate></item><item><title>Bash - wyodrębnianie danych IPTC XMP ze zdjęcia</title><link>https://sataks.github.io/posts/bash-wyodrebnianie-danych-iptc-xmp-ze-zdjecia/</link><dc:creator>tk</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;img alt="Bash" src="https://satkas.waw.pl/plugins/news_manager/browser/pic.php?p=https://satkas.waw.pl/data/thumbs/images/thumbnail.bash-logo-web.png&amp;amp;c=1" title="Bash"&gt;&lt;/p&gt;
&lt;p&gt;Jeśli chcemy wydobyć jakąś pojedyńczą sekcję (fotografa, agencję lub opis) ze zdjęcia można użyć narzędzia exiv2.&lt;/p&gt;
&lt;p&gt;Wyodrębnienie całości metadanych ze zdjęcia do pliku:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;exiv2 -ea image.jpg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ta komenda utworzy plik o tej samej nazwie co zdjęcie z rozszerzeniem .exv&lt;/p&gt;
&lt;p&gt;Wstrzyknięcie tych samych danych z pliku .exv do zdjęcia:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;exiv2 -kia image.jpg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aby wyodrębnić konkretną sekcję np IPTC wydajemy komendę:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;exiv2 -PI image.jpg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;lub&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;exiv2 -pi image.jpg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jeśli chcemy tylko wyodrębnić np. tytuł wydarzenia uwieńczonego na zdjęciu wydajemy komendę:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;exiv2 -PIv -g Iptc.Application2.Headline
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oczywiście musimy być pewni, że fotograf, agencja foto podpisuje swoje zdjęcia w programie do edycji meta danych. Inaczej nic nie zobaczymy. Osoby prywatne raczej nie opisują zdjęć więc zobaczysz tylko metadane EXIF(metadane generowane przez aparat fotograficzny).&lt;/p&gt;
&lt;p&gt;Jeśli chcemy dodać pojedyńcze rekordy w sekcji np IPTC wydajemy komendę:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;exiv2 -kM&lt;span class="s2"&gt;"add Iptc.Application2.Headline Jakiś tytuł wydarzenia na zdjęciu"&lt;/span&gt; image.jpg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Usunięcie sekcji IPTC, XMP, EXIF wykonamy narzędziem jhead&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;jhead -dc -de -di -dx image.jpg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oba narzędzia exiv2 i jhead zainstalujemy w ubuntu&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo apt install exiv2 jhead
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><category>bash</category><category>linux</category><category>skrypt</category><guid>https://sataks.github.io/posts/bash-wyodrebnianie-danych-iptc-xmp-ze-zdjecia/</guid><pubDate>Mon, 21 May 2018 22:00:00 GMT</pubDate></item><item><title>Bash - pojemność katalogu z filtrem na pliki</title><link>https://sataks.github.io/posts/bash-pojemnosc-katalogu-z-filtrem-na-pliki/</link><dc:creator>tk</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;img alt="Bash" src="https://satkas.waw.pl/plugins/news_manager/browser/pic.php?p=https://satkas.waw.pl/data/thumbs/images/thumbnail.bash-logo-web.png&amp;amp;c=1" title="Bash"&gt;&lt;/p&gt;
&lt;p&gt;Zawartość skryptu. Skrypt posiada 2 zmienne. Zmienna $folder to obliczany folder. Zmienna $ext to rozszerzenie plików, które będą zliczane. Skrypt oblicza pojemność katalogu rekursywnie i ogranicza się tylko do plików jpg  &lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="nv"&gt;folder&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'/home/user/Obrazy'&lt;/span&gt;
&lt;span class="nv"&gt;ext&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'.jpg'&lt;/span&gt;

foldersize&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; -d &lt;span class="nv"&gt;$folder&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
        &lt;span class="nv"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;ls -alRF &lt;span class="nv"&gt;$folder&lt;/span&gt;/ &lt;span class="p"&gt;|&lt;/span&gt; grep -i &lt;span class="nv"&gt;$ext&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;'BEGIN {tot=0} { tot=tot+$5 } END { print tot }'&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
        &lt;span class="nv"&gt;countsize&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="si"&gt;${#&lt;/span&gt;&lt;span class="nv"&gt;size&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;
        &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Znaków: &lt;/span&gt;&lt;span class="nv"&gt;$countsize&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
        &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Podliczanie plików &lt;/span&gt;&lt;span class="nv"&gt;$ext&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$countsize&lt;/span&gt; -lt &lt;span class="m"&gt;4&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;then&lt;/span&gt;
         &lt;span class="nb"&gt;echo&lt;/span&gt; -n &lt;span class="s2"&gt;"Zajętość katalogu `realpath &lt;/span&gt;&lt;span class="nv"&gt;$folder&lt;/span&gt;&lt;span class="s2"&gt;`"&lt;/span&gt;
         &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;size&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;B"&lt;/span&gt;
        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$countsize&lt;/span&gt; -ge &lt;span class="m"&gt;4&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$countsize&lt;/span&gt; -lt &lt;span class="m"&gt;7&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;then&lt;/span&gt;
         &lt;span class="nb"&gt;echo&lt;/span&gt; -n &lt;span class="s2"&gt;"Zajętość katalogu `realpath &lt;/span&gt;&lt;span class="nv"&gt;$folder&lt;/span&gt;&lt;span class="s2"&gt;` w KB: "&lt;/span&gt;
         &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"scale=2;&lt;/span&gt;&lt;span class="nv"&gt;$size&lt;/span&gt;&lt;span class="s2"&gt;/1024"&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;bc -l
        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$countsize&lt;/span&gt; -ge &lt;span class="m"&gt;7&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$countsize&lt;/span&gt; -le &lt;span class="m"&gt;9&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;then&lt;/span&gt;
         &lt;span class="nb"&gt;echo&lt;/span&gt; -n &lt;span class="s2"&gt;"Zajętość katalogu `realpath &lt;/span&gt;&lt;span class="nv"&gt;$folder&lt;/span&gt;&lt;span class="s2"&gt;` w MB: "&lt;/span&gt;
         &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"scale=2;&lt;/span&gt;&lt;span class="nv"&gt;$size&lt;/span&gt;&lt;span class="s2"&gt;/1024/1024"&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;bc -l
        &lt;span class="k"&gt;else&lt;/span&gt;
         &lt;span class="nb"&gt;echo&lt;/span&gt; -n &lt;span class="s2"&gt;"Zajętość katalogu `realpath &lt;/span&gt;&lt;span class="nv"&gt;$folder&lt;/span&gt;&lt;span class="s2"&gt;` w GB: "&lt;/span&gt;
         &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"scale=2;&lt;/span&gt;&lt;span class="nv"&gt;$size&lt;/span&gt;&lt;span class="s2"&gt;/1024/1024/1024"&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;bc -l
        &lt;span class="k"&gt;fi&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$folder&lt;/span&gt;&lt;span class="s2"&gt;: folder does not exist"&lt;/span&gt;
    &lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

foldersize
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><category>bash</category><category>linux</category><category>skrypt</category><guid>https://sataks.github.io/posts/bash-pojemnosc-katalogu-z-filtrem-na-pliki/</guid><pubDate>Mon, 14 May 2018 22:00:00 GMT</pubDate></item></channel></rss>